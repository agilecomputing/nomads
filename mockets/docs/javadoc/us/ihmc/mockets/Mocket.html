<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_15) on Thu Oct 22 11:20:38 CDT 2009 -->
<TITLE>
Mocket
</TITLE>

<META NAME="date" CONTENT="2009-10-22">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet_modified.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Mocket";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../us/ihmc/mockets/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../us/ihmc/mockets/Mocket.Sender.html" title="class in us.ihmc.mockets"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?us/ihmc/mockets/Mocket.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Mocket.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
us.ihmc.mockets</FONT>
<BR>
Class Mocket</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>us.ihmc.mockets.Mocket</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Mocket</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
The main class for a client application to use the Mockets communication library.
 Similar in functionality to a socket. Used by a client to establish a connection
 to a server and then communicate with the server.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.Sender.html" title="class in us.ihmc.mockets">Mocket.Sender</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The class used to send messages over Mockets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.Statistics.html" title="class in us.ihmc.mockets">Mocket.Statistics</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The class that contains statistics about an active mocket connection.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#Mocket()">Mocket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new, unconnected Mocket endpoint.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#bind(java.net.SocketAddress)">bind</A></B>(java.net.SocketAddress&nbsp;addr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binds the local end point to a particular address (interface) and port.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#cancel(boolean, boolean, int)">cancel</A></B>(boolean&nbsp;reliable,
       boolean&nbsp;sequenced,
       int&nbsp;tagId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancels (deletes) previously enqueued messages that have been tagged with the specified tag.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closes the current open connection to a remote endpoint.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#connect(java.net.InetSocketAddress)">connect</A></B>(java.net.InetSocketAddress&nbsp;addr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to connect to a <code>ServerMocket</code>, address and port are specified using an IP Socket Address.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#connect(java.net.SocketAddress, long)">connect</A></B>(java.net.SocketAddress&nbsp;addr,
        long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to connect to a <code>ServerMocket</code>, address and port are specified as a Socket Address.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#connect(java.lang.String, int)">connect</A></B>(java.lang.String&nbsp;remoteHost,
        int&nbsp;remotePort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to connect to a <code>ServerMocket</code> at the specified remote host on the specified remote port.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#connect(java.lang.String, int, long)">connect</A></B>(java.lang.String&nbsp;remoteHost,
        int&nbsp;remotePort,
        long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to connect to a <code>ServerMocket</code> at the specified remote host on the specified remote port, and
 choosing the connection attempt timeout.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#enableCrossSequecing(boolean)">enableCrossSequecing</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables cross sequencing across the reliable sequenced and unreliable sequenced packets.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#finalize()">finalize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Native method that removes <code>mocket</code> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getConnectionLingerTime()">getConnectionLingerTime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current setting for the connection linger time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getIdentifier()">getIdentifier</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the identifier for this mocket instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getMaximumMTU()">getMaximumMTU</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the maximum MTU that may be used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getNextMessageSize(long)">getNextMessageSize</A></B>(long&nbsp;Timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the size of the next message that is ready to be delivered to the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.net.SocketAddress</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getPeerName()">getPeerName</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extract the address of the peer in the form Socket Address.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getRemoteAddress()">getRemoteAddress</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Native method that returns the IP addess of the remote host.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getRemotePort()">getRemotePort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Native method that returns the remote port to which the connection has been established.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../us/ihmc/mockets/Mocket.Sender.html" title="class in us.ihmc.mockets">Mocket.Sender</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getSender(boolean, boolean)">getSender</A></B>(boolean&nbsp;reliable,
          boolean&nbsp;sequenced)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains a new sender with the specified combination of reliability and sequencing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../us/ihmc/mockets/Mocket.Statistics.html" title="class in us.ihmc.mockets">Mocket.Statistics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#getStatistics()">getStatistics</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a pointer to the Statistics class that maintains statistics about this mocket connection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#gsend(boolean, boolean, byte[], int, int, int, short, long, long, java.lang.String, java.lang.String)">gsend</A></B>(boolean&nbsp;reliable,
      boolean&nbsp;sequenced,
      byte[]&nbsp;buffer,
      int&nbsp;offset,
      int&nbsp;length,
      int&nbsp;tag,
      short&nbsp;priority,
      long&nbsp;enqueueTimeout,
      long&nbsp;retryTimeout,
      java.lang.String&nbsp;valist1,
      java.lang.String&nbsp;valist2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#gsend(boolean, boolean, byte[], int, short, long, long, java.lang.String, java.lang.String)">gsend</A></B>(boolean&nbsp;reliable,
      boolean&nbsp;sequenced,
      byte[]&nbsp;buffer,
      int&nbsp;tag,
      short&nbsp;priority,
      long&nbsp;enqueueTimeout,
      long&nbsp;retryTimeout,
      java.lang.String&nbsp;valist1,
      java.lang.String&nbsp;valist2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#isCrossSequencingEnabled()">isCrossSequencingEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current setting for cross sequencing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#receive(byte[])">receive</A></B>(byte[]&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from next message that is ready to be delivered to the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#receive(byte[], int, int)">receive</A></B>(byte[]&nbsp;buffer,
        int&nbsp;offset,
        int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from next message that is ready to be delivered to the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#receive(byte[], int, int, long)">receive</A></B>(byte[]&nbsp;buffer,
        int&nbsp;offset,
        int&nbsp;length,
        long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from next message that is ready to be delivered to the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#receive(byte[], long)">receive</A></B>(byte[]&nbsp;buffer,
        long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from next message that is ready to be delivered to the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#receive(long)">receive</A></B>(long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from next message that is ready to be delivered to the application.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#replace(boolean, boolean, byte[], int, int, int, int, short, long, long)">replace</A></B>(boolean&nbsp;reliable,
        boolean&nbsp;sequenced,
        byte[]&nbsp;buffer,
        int&nbsp;offset,
        int&nbsp;length,
        int&nbsp;oldTag,
        int&nbsp;newTag,
        short&nbsp;priority,
        long&nbsp;enqueueTimeout,
        long&nbsp;retryTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First cancels any previously enqueued messages that have been tagged with the specified <code>OldTag</code>
 value and then transmits the new message using the specified parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#replace(boolean, boolean, byte[], int, int, short, long, long)">replace</A></B>(boolean&nbsp;reliable,
        boolean&nbsp;sequenced,
        byte[]&nbsp;buffer,
        int&nbsp;oldTag,
        int&nbsp;newTag,
        short&nbsp;priority,
        long&nbsp;enqueueTimeout,
        long&nbsp;retryTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First cancels any previously enqueued messages that have been tagged with the specified <code>OldTag</code>
 value and then transmits the new message using the specified parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#send(boolean, boolean, byte[], int, int, int, short, long, long)">send</A></B>(boolean&nbsp;reliable,
     boolean&nbsp;sequenced,
     byte[]&nbsp;buffer,
     int&nbsp;offset,
     int&nbsp;length,
     int&nbsp;tag,
     short&nbsp;priority,
     long&nbsp;enqueueTimeout,
     long&nbsp;retryTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enqueues the specified data for transmission.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#send(boolean, boolean, byte[], int, short, long, long)">send</A></B>(boolean&nbsp;reliable,
     boolean&nbsp;sequenced,
     byte[]&nbsp;buffer,
     int&nbsp;tag,
     short&nbsp;priority,
     long&nbsp;enqueueTimeout,
     long&nbsp;retryTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enqueues the specified data for transmission.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#setConnectionLingerTime(long)">setConnectionLingerTime</A></B>(long&nbsp;lingerTime)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the length of time (in milliseconds) for which a connection should linger before
 closing in case there is unsent data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#setIdentifier(java.lang.String)">setIdentifier</A></B>(java.lang.String&nbsp;identifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a string to use as the application or user friendly identifier for this mocket instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#setStatusListener(us.ihmc.mockets.MocketStatusListener)">setStatusListener</A></B>(<A HREF="../../../us/ihmc/mockets/MocketStatusListener.html" title="interface in us.ihmc.mockets">MocketStatusListener</A>&nbsp;msl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Register a callback function to be invoked when no data (or keepalive) has
 been received from the peer mocket.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#sreceive(byte[], byte[], byte[], byte[], long)">sreceive</A></B>(byte[]&nbsp;buf1,
         byte[]&nbsp;buf2,
         byte[]&nbsp;buf3,
         byte[]&nbsp;buf4,
         long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#sreceive(byte[], byte[], byte[], long)">sreceive</A></B>(byte[]&nbsp;buf1,
         byte[]&nbsp;buf2,
         byte[]&nbsp;buf3,
         long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#sreceive(byte[], byte[], long)">sreceive</A></B>(byte[]&nbsp;buf1,
         byte[]&nbsp;buf2,
         long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#sreceive(byte[], int, int, byte[], int, int, byte[], int, int, byte[], int, int, long)">sreceive</A></B>(byte[]&nbsp;buf1,
         int&nbsp;offset1,
         int&nbsp;length1,
         byte[]&nbsp;buf2,
         int&nbsp;offset2,
         int&nbsp;length2,
         byte[]&nbsp;buf3,
         int&nbsp;offset3,
         int&nbsp;length3,
         byte[]&nbsp;buf4,
         int&nbsp;offset4,
         int&nbsp;length4,
         long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#sreceive(byte[], int, int, byte[], int, int, byte[], int, int, long)">sreceive</A></B>(byte[]&nbsp;buf1,
         int&nbsp;offset1,
         int&nbsp;length1,
         byte[]&nbsp;buf2,
         int&nbsp;offset2,
         int&nbsp;length2,
         byte[]&nbsp;buf3,
         int&nbsp;offset3,
         int&nbsp;length3,
         long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../us/ihmc/mockets/Mocket.html#sreceive(byte[], int, int, byte[], int, int, long)">sreceive</A></B>(byte[]&nbsp;buf1,
         int&nbsp;offset1,
         int&nbsp;length1,
         byte[]&nbsp;buf2,
         int&nbsp;offset2,
         int&nbsp;length2,
         long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Mocket()"><!-- --></A><H3>
Mocket</H3>
<PRE>
public <B>Mocket</B>()</PRE>
<DL>
<DD>Creates a new, unconnected Mocket endpoint.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setStatusListener(us.ihmc.mockets.MocketStatusListener)"><!-- --></A><H3>
setStatusListener</H3>
<PRE>
public void <B>setStatusListener</B>(<A HREF="../../../us/ihmc/mockets/MocketStatusListener.html" title="interface in us.ihmc.mockets">MocketStatusListener</A>&nbsp;msl)</PRE>
<DL>
<DD>Register a callback function to be invoked when no data (or keepalive) has
 been received from the peer mocket.
 The callback will indicate the time (in milliseconds) since last contact.
 If the callback returns true, the mocket connection will be closed.
 The peer is declared unreachable and the callback is invoked if no messages
 are received from the peer for more than 2 seconds.
 This waiting time is twice the default interval between keep-alive messages.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>msl</CODE> - callback function to register.</DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.lang.String, int)"><!-- --></A><H3>
connect</H3>
<PRE>
public int <B>connect</B>(java.lang.String&nbsp;remoteHost,
                   int&nbsp;remotePort)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Attempts to connect to a <code>ServerMocket</code> at the specified remote host on the specified remote port.
 The host may be a hostname that can be resolved to an IP address or an IP address in string format (e.g. "127.0.0.1").
 The default connection timeout is 30 seconds.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>remoteHost</CODE> - hostname of the remote host. It can be an IP address a string hostname that will be resolved.<DD><CODE>remotePort</CODE> - port where the <code>ServerMocket</code> is listening.
<DT><B>Returns:</B><DD><ul class="return">
                      <li><code>0</code> if the connection is successfully established;</li>
                      <li><code>-1</code> if the state of the mocket is not closed. The connection has already been established;</li>
                      <li><code>-2</code> if the port to connect to is null;</li>
                      <li><code>-3</code> if the lookup of the IP address failed;</li>
                      <li><code>-4</code> if the initialization of datagram socket failed;</li>
                      <li><code>-5</code> if setting UDP receiver buffer failed;</li>
                      <li><code>-6</code> if setting UDP timeout failed;</li>
                      <li><code>-7</code> if mocket state machine is in illegal state when receiving InitAck;</li>
                      <li><code>-8</code> if the connection timed out while waiting for InitAck;</li>
                      <li><code>-9</code> if mocket state machine is in illegal state when receiving CookieAck;</li>
                      <li><code>-10</code> if the connection timed out while waiting for CookieAck;</li>
                      <li><code>-20</code> if <code>remotePort</code> has an illegal value (less then zero);</li>
                      <li><code>-21</code> if <code>remoteHost</code> has an illegal value, host is null;</li>
                      <li><code>-22</code> if the object mocket is not initialized, mocket is null.</li>
                      </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.lang.String, int, long)"><!-- --></A><H3>
connect</H3>
<PRE>
public int <B>connect</B>(java.lang.String&nbsp;remoteHost,
                   int&nbsp;remotePort,
                   long&nbsp;timeout)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Attempts to connect to a <code>ServerMocket</code> at the specified remote host on the specified remote port, and
 choosing the connection attempt timeout.
 The host may be a hostname that can be resolved to an IP address or an IP address in string format (e.g. "127.0.0.1").
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>remoteHost</CODE> - hostname of the remote host. It can be an IP address a string hostname that will be resolved.<DD><CODE>remotePort</CODE> - port where the <code>ServerMocket</code> is listening.<DD><CODE>timeout</CODE> - time in milliseconds while mocket will attempt to connect to <code>ServerMocket</code>.
<DT><B>Returns:</B><DD><ul class="return">
                      <li><code>0</code> if the connection is successfully established;</li>
                      <li><code>-1</code> if the state of the mocket is not closed. The connection has already been established;</li>
                      <li><code>-2</code> if the port to connect to is null;</li>
                      <li><code>-3</code> if the lookup of the IP address failed;</li>
                      <li><code>-4</code> if the initialization of datagram socket failed;</li>
                      <li><code>-5</code> if setting UDP receiver buffer failed;</li>
                      <li><code>-6</code> if setting UDP timeout failed;</li>
                      <li><code>-7</code> if mocket state machine is in illegal state when receiving InitAck;</li>
                      <li><code>-8</code> if the connection timed out while waiting for InitAck;</li>
                      <li><code>-9</code> if mocket state machine is in illegal state when receiving CookieAck;</li>
                      <li><code>-10</code> if the connection timed out while waiting for CookieAck;</li>
                      <li><code>-20</code> if <code>remotePort</code> has an illegal value (less then zero);</li>
                      <li><code>-21</code> if <code>remoteHost</code> has an illegal value, host is null;</li>
                      <li><code>-22</code> if the object mocket is not initialized, mocket is null.</li>
                      </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.net.InetSocketAddress)"><!-- --></A><H3>
connect</H3>
<PRE>
public int <B>connect</B>(java.net.InetSocketAddress&nbsp;addr)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Attempts to connect to a <code>ServerMocket</code>, address and port are specified using an IP Socket Address.
 The default connection timeout is 30 seconds.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>addr</CODE> - remote host address specified as an IP Socket Address.
<DT><B>Returns:</B><DD><ul class="return">
                      <li><code>0</code> if the connection is successfully established;</li>
                      <li><code>-1</code> if the state of the mocket is not closed. The connection has already been established;</li>
                      <li><code>-2</code> if the port to connect to is null;</li>
                      <li><code>-3</code> if the lookup of the IP address failed;</li>
                      <li><code>-4</code> if the initialization of datagram socket failed;</li>
                      <li><code>-5</code> if setting UDP receiver buffer failed;</li>
                      <li><code>-6</code> if setting UDP timeout failed;</li>
                      <li><code>-7</code> if mocket state machine is in illegal state when receiving InitAck;</li>
                      <li><code>-8</code> if the connection timed out while waiting for InitAck;</li>
                      <li><code>-9</code> if mocket state machine is in illegal state when receiving CookieAck;</li>
                      <li><code>-10</code> if the connection timed out while waiting for CookieAck;</li>
                      <li><code>-20</code> if <code>remotePort</code> has an illegal value (less then zero);</li>
                      <li><code>-21</code> if <code>remoteHost</code> has an illegal value, host is null;</li>
                      <li><code>-22</code> if the object mocket is not initialized, mocket is null.</li>
                      </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE><DT><B>See Also:</B><DD><CODE>InetSocketAddress</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.net.SocketAddress, long)"><!-- --></A><H3>
connect</H3>
<PRE>
public int <B>connect</B>(java.net.SocketAddress&nbsp;addr,
                   long&nbsp;timeout)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Attempts to connect to a <code>ServerMocket</code>, address and port are specified as a Socket Address.
 Allows to choose the connection attempt timeout.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>addr</CODE> - remote host address specified as a SocketAddress.<DD><CODE>timeout</CODE> - time in milliseconds while mocket will attempt to connect to <code>ServerMocket</code>.
<DT><B>Returns:</B><DD><ul class="return">
                      <li><code>0</code> if the connection is successfully established;</li>
                      <li><code>-1</code> if the state of the mocket is not closed. The connection has already been established;</li>
                      <li><code>-2</code> if the port to connect to is null;</li>
                      <li><code>-3</code> if the lookup of the IP address failed;</li>
                      <li><code>-4</code> if the initialization of datagram socket failed;</li>
                      <li><code>-5</code> if setting UDP receiver buffer failed;</li>
                      <li><code>-6</code> if setting UDP timeout failed;</li>
                      <li><code>-7</code> if mocket state machine is in illegal state when receiving InitAck;</li>
                      <li><code>-8</code> if the connection timed out while waiting for InitAck;</li>
                      <li><code>-9</code> if mocket state machine is in illegal state when receiving CookieAck;</li>
                      <li><code>-10</code> if the connection timed out while waiting for CookieAck;</li>
                      <li><code>-20</code> if <code>remotePort</code> has an illegal value (less then zero);</li>
                      <li><code>-21</code> if <code>remoteHost</code> has an illegal value, host is null;</li>
                      <li><code>-22</code> if the object mocket is not initialized, mocket is null.</li>
                      </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="bind(java.net.SocketAddress)"><!-- --></A><H3>
bind</H3>
<PRE>
public int <B>bind</B>(java.net.SocketAddress&nbsp;addr)
         throws java.io.IOException,
                java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Binds the local end point to a particular address (interface) and port.
 Calls to this method will work if invoked before calling <code>connect</code>
 otherwise, it will return an error code.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>addr</CODE> - remote host address specified as a SocketAddress.
<DT><B>Returns:</B><DD><code>0</code> if success;
              <code>&#60;0</code> if error.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getRemoteAddress()"><!-- --></A><H3>
getRemoteAddress</H3>
<PRE>
public long <B>getRemoteAddress</B>()
                      throws java.io.IOException,
                             java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Native method that returns the IP addess of the remote host.
 The address is represented as a long value.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>remote host address.
          <code>-1</code> if the object mocket is not initialized, mocket is null.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getRemotePort()"><!-- --></A><H3>
getRemotePort</H3>
<PRE>
public int <B>getRemotePort</B>()
                  throws java.io.IOException,
                         java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Native method that returns the remote port to which the connection has been established.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>remote port as an int value.
          <code>-1</code> if the object mocket is not initialized, mocket is null.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public int <B>close</B>()
          throws java.io.IOException,
                 java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Closes the current open connection to a remote endpoint.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>0</code> if it ends successfully or if the connection was already closed;
          <code>-1</code> if the connection we are attempting to close is not in the ESTABLISHED state.
          <code>-10</code> if the object mocket is not initialized, mocket is null.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="enableCrossSequecing(boolean)"><!-- --></A><H3>
enableCrossSequecing</H3>
<PRE>
public int <B>enableCrossSequecing</B>(boolean&nbsp;enable)
                         throws java.io.IOException,
                                java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Enables or disables cross sequencing across the reliable sequenced and unreliable sequenced packets.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - boolean value to indicate if we want to enable (true) or disable (false) the cross sequencing.
<DT><B>Returns:</B><DD><code>0</code> if ends with success.
                  <code>-1</code> if the object mocket is not initialized, mocket is null.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isCrossSequencingEnabled()"><!-- --></A><H3>
isCrossSequencingEnabled</H3>
<PRE>
public boolean <B>isCrossSequencingEnabled</B>()
                                 throws java.io.IOException,
                                        java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Returns the current setting for cross sequencing.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>boolean value that indicates if cross sequencing is enabled.
          <code>-1</code> if the object mocket is not initialized, mocket is null.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE><DT><B>See Also:</B><DD><A HREF="../../../us/ihmc/mockets/Mocket.html#enableCrossSequecing(boolean)"><CODE>enableCrossSequecing(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSender(boolean, boolean)"><!-- --></A><H3>
getSender</H3>
<PRE>
public <A HREF="../../../us/ihmc/mockets/Mocket.Sender.html" title="class in us.ihmc.mockets">Mocket.Sender</A> <B>getSender</B>(boolean&nbsp;reliable,
                               boolean&nbsp;sequenced)</PRE>
<DL>
<DD>Obtains a new sender with the specified combination of reliability and sequencing.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).
<DT><B>Returns:</B><DD>a <code>Sender</code> object to be used to send messages;
                  <code>NULL</code> if the objects mocket or sender are not initialized, mocket or sender is null.<DT><B>See Also:</B><DD><A HREF="../../../us/ihmc/mockets/Mocket.Sender.html" title="class in us.ihmc.mockets"><CODE>Mocket.Sender</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="send(boolean, boolean, byte[], int, short, long, long)"><!-- --></A><H3>
send</H3>
<PRE>
public int <B>send</B>(boolean&nbsp;reliable,
                boolean&nbsp;sequenced,
                byte[]&nbsp;buffer,
                int&nbsp;tag,
                short&nbsp;priority,
                long&nbsp;enqueueTimeout,
                long&nbsp;retryTimeout)
         throws java.io.IOException,
                java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Enqueues the specified data for transmission.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).<DD><CODE>buffer</CODE> - the buffer to be sent. The buffer is going to be sent entirely.<DD><CODE>tag</CODE> - used to identify the type of the packet.<DD><CODE>priority</CODE> - indicates the priority of the packet. The range of priority values is 0-255.<DD><CODE>enqueueTimeout</CODE> - indicates the length of time in milliseconds for which the method will wait if
                          there is no room in the outgoing buffer (a zero value indicates wait forever).<DD><CODE>retryTimeout</CODE> - indicates the length of time for which the transmitter will retransmit the packet
                          to ensure successful delivery (a zero value indicates retry with no time limit).
<DT><B>Returns:</B><DD><code>0</code> if ends with success.
                          <code>&#60;0</code> if an error occurs.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="send(boolean, boolean, byte[], int, int, int, short, long, long)"><!-- --></A><H3>
send</H3>
<PRE>
public int <B>send</B>(boolean&nbsp;reliable,
                boolean&nbsp;sequenced,
                byte[]&nbsp;buffer,
                int&nbsp;offset,
                int&nbsp;length,
                int&nbsp;tag,
                short&nbsp;priority,
                long&nbsp;enqueueTimeout,
                long&nbsp;retryTimeout)
         throws java.io.IOException,
                java.lang.IllegalArgumentException,
                java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Enqueues the specified data for transmission.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).<DD><CODE>buffer</CODE> - the buffer to be sent.<DD><CODE>offset</CODE> - the position in the buffer we start to send from.
                          E.g. offset=10, we send buffer starting at the 10th byte in the array.<DD><CODE>length</CODE> - the length for which we send.
                          E.g. length=50 we send 50 bytes of the buffer, starting at offset.
                          If offset=10, length=50 we send bytes from position 10 in the
                          buffer through position 60.<DD><CODE>tag</CODE> - used to identify the type of the packet.<DD><CODE>priority</CODE> - indicates the priority of the packet. The range of priority values is 0-255.<DD><CODE>enqueueTimeout</CODE> - indicates the length of time in milliseconds for which the method will wait if
                          there is no room in the outgoing buffer (a zero value indicates wait forever).<DD><CODE>retryTimeout</CODE> - indicates the length of time for which the transmitter will retransmit the packet
                          to ensure successful delivery (a zero value indicates retry with no time limit).
<DT><B>Returns:</B><DD><code>0</code> if ends with success.
                          <code>&#60;0</code> if an error occurs.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters <code>offset</code> or 
                                              <code>length</code> are illegal for <code>buffer</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="gsend(boolean, boolean, byte[], int, short, long, long, java.lang.String, java.lang.String)"><!-- --></A><H3>
gsend</H3>
<PRE>
public int <B>gsend</B>(boolean&nbsp;reliable,
                 boolean&nbsp;sequenced,
                 byte[]&nbsp;buffer,
                 int&nbsp;tag,
                 short&nbsp;priority,
                 long&nbsp;enqueueTimeout,
                 long&nbsp;retryTimeout,
                 java.lang.String&nbsp;valist1,
                 java.lang.String&nbsp;valist2)
          throws java.io.IOException,
                 java.lang.IllegalArgumentException</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).<DD><CODE>buffer</CODE> - the buffer to be sent. The buffer is going to be sent entirely.<DD><CODE>tag</CODE> - used to identify the type of the packet.<DD><CODE>priority</CODE> - indicates the priority of the packet. The range of priority values is 0-255.<DD><CODE>enqueueTimeout</CODE> - indicates the length of time in milliseconds for which the method will wait if
                         there is no room in the outgoing buffer (a zero value indicates wait forever).<DD><CODE>retryTimeout</CODE> - indicates the length of time for which the transmitter will retransmit the packet
                         to ensure successful delivery (a zero value indicates retry with no time limit).<DD><CODE>valist1</CODE> - <DD><CODE>valist2</CODE> - 
<DT><B>Returns:</B><DD>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="gsend(boolean, boolean, byte[], int, int, int, short, long, long, java.lang.String, java.lang.String)"><!-- --></A><H3>
gsend</H3>
<PRE>
public int <B>gsend</B>(boolean&nbsp;reliable,
                 boolean&nbsp;sequenced,
                 byte[]&nbsp;buffer,
                 int&nbsp;offset,
                 int&nbsp;length,
                 int&nbsp;tag,
                 short&nbsp;priority,
                 long&nbsp;enqueueTimeout,
                 long&nbsp;retryTimeout,
                 java.lang.String&nbsp;valist1,
                 java.lang.String&nbsp;valist2)
          throws java.io.IOException,
                 java.lang.IllegalArgumentException,
                 java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).<DD><CODE>buffer</CODE> - the buffer to be sent. The buffer is going to be sent entirely.<DD><CODE>offset</CODE> - the position in the buffer we start to send from.
                          E.g. offset=10, we send buffer starting at the 10th byte in the array.<DD><CODE>length</CODE> - the length for which we send.
                          E.g. length=50 we send 50 bytes of the buffer, starting at offset.
                          If offset=10, length=50 we send bytes from position 10 in the
                          buffer through position 60.<DD><CODE>tag</CODE> - used to identify the type of the packet.<DD><CODE>priority</CODE> - indicates the priority of the packet. The range of priority values is 0-255.<DD><CODE>enqueueTimeout</CODE> - indicates the length of time in milliseconds for which the method will wait if
                          there is no room in the outgoing buffer (a zero value indicates wait forever).<DD><CODE>retryTimeout</CODE> - indicates the length of time for which the transmitter will retransmit the packet
                          to ensure successful delivery (a zero value indicates retry with no time limit).<DD><CODE>valist1</CODE> - <DD><CODE>valist2</CODE> - 
<DT><B>Returns:</B><DD>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters <code>offset</code> or
                                              <code>length</code> are illegal for <code>buffer</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="getNextMessageSize(long)"><!-- --></A><H3>
getNextMessageSize</H3>
<PRE>
public int <B>getNextMessageSize</B>(long&nbsp;Timeout)
                       throws java.io.IOException,
                              java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Returns the size of the next message that is ready to be delivered to the application.
 If no message is available, the call will block based on the timeout parameter.
 A timeout of 0 implies that the default timeout should be used
 whereas a timeout of -1 implies wait indefinitely.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>Timeout</CODE> - milliseconds to wait for a message available. A 0 value means use the default timeout (-1).
                  A -1 value means wait indefinitely.
<DT><B>Returns:</B><DD>size of the message waiting to be read, in bytes;
                  <code>0</code> if no data is available in the specified timeout;
                  <code>-1</code> if the connection has been closed.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="receive(byte[])"><!-- --></A><H3>
receive</H3>
<PRE>
public int <B>receive</B>(byte[]&nbsp;buffer)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Retrieves the data from next message that is ready to be delivered to the application.
 At most <code>buffer.length</code> bytes are copied into the specified buffer. 
 NOTE: Any additional data in the packet that will not fit in the buffer is discarded.
 The receive is a blocking function, waits until there are data to be received or the timeout expires.
 The timeout is not specified, the default value is going to be used. The default value is -1.
 A timeout of -1 implies wait indefinitely.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - byte array where the data is copied for delivery.
<DT><B>Returns:</B><DD><ul class="return">
                  <li>returns the number of bytes that were copied into the buffer;</li>
                  <li><code>-1</code> if an error occurred;</li>
                  <li><code>-10</code> if the object mocket is not initialized, mocket is null;</li>
                  <li><code>-11</code> if the parameter <code>buffer</code> is invalid, <code>buffer</code> is null.</li>
                  </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="receive(byte[], int, int)"><!-- --></A><H3>
receive</H3>
<PRE>
public int <B>receive</B>(byte[]&nbsp;buffer,
                   int&nbsp;offset,
                   int&nbsp;length)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException,
                   java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Retrieves the data from next message that is ready to be delivered to the application.
 The bytes are copied into the specified buffer starting at the specified offset.
 At most <code>length</code> bytes are copied. 
 NOTE: Any additional data in the packet that will not fit in the buffer is discarded.
 The receive is a blocking function, waits until there are data to be received or the timeout expires.
 The timeout is not specified, the default value is going to be used. The default value is -1.
 A timeout of -1 implies wait indefinitely.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - byte array where the data is copied for delivery.<DD><CODE>offset</CODE> - the point in the buffer where we start to copy the data.<DD><CODE>length</CODE> - the number of bytes that are copied into the buffer.
<DT><B>Returns:</B><DD><ul class="return">
                  <li>returns the number of bytes that were copied into the buffer;</li>
                  <li><code>-1</code> if an error occurred;</li>
                  <li><code>-10</code> if the object mocket is not initialized, mocket is null;</li>
                  <li><code>-11</code> if the parameter <code>buffer</code> is invalid, <code>buffer</code> is null.</li>
                  </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters <code>offset</code> or 
                                              <code>length</code> are illegal for <code>buffer</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="receive(byte[], long)"><!-- --></A><H3>
receive</H3>
<PRE>
public int <B>receive</B>(byte[]&nbsp;buffer,
                   long&nbsp;timeout)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Retrieves the data from next message that is ready to be delivered to the application.
 At most <code>buffer.length</code> bytes are copied into the specified buffer. 
 NOTE: Any additional data in the packet that will not fit in the buffer is discarded.
 The receive is a blocking function, waits until there are data to be received or the timeout expires.
 This function allows to specify a value for the timeout.
 Specifying a timeout of 0 implies that the default timeout should be used whereas a timeout
 of -1 implies wait indefinitely. The default timeout is -1.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - byte array where the data is copied for delivery.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD><ul class="return">
                  <li>returns the number of bytes that were copied into the buffer;</li>
                  <li><code>-1</code> if an error occurred;</li>
                  <li><code>-10</code> if the object mocket is not initialized, mocket is null;</li>
                  <li><code>-11</code> if the parameter <code>buffer</code> is invalid, <code>buffer</code> is null.</li>
                  </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="receive(byte[], int, int, long)"><!-- --></A><H3>
receive</H3>
<PRE>
public int <B>receive</B>(byte[]&nbsp;buffer,
                   int&nbsp;offset,
                   int&nbsp;length,
                   long&nbsp;timeout)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException,
                   java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Retrieves the data from next message that is ready to be delivered to the application.
 The bytes are copied into the specified buffer starting at the specified offset.
 At most <code>length</code> bytes are copied. 
 NOTE: Any additional data in the packet that will not fit in the buffer is discarded.
 The receive is a blocking function, waits until there are data to be received or the timeout expires.
 This function allows to specify a value for the timeout.
 Specifying a timeout of 0 implies that the default timeout should be used whereas a timeout
 of -1 implies wait indefinitely. The default timeout is -1.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - byte array where the data is copied for delivery.<DD><CODE>offset</CODE> - the point in the buffer where we start to copy the data.<DD><CODE>length</CODE> - the number of bytes that are copied into the buffer.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD><ul class="return">
                  <li>returns the number of bytes that were copied into the buffer;</li>
                  <li><code>-1</code> if an error occurred;</li>
                  <li><code>-10</code> if the object mocket is not initialized, mocket is null;</li>
                  <li><code>-11</code> if the parameter <code>buffer</code> is invalid, <code>buffer</code> is null.</li>
                  </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters <code>offset</code> or 
                                              <code>length</code> are illegal for <code>buffer</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="receive(long)"><!-- --></A><H3>
receive</H3>
<PRE>
public byte[] <B>receive</B>(long&nbsp;timeout)
               throws java.io.IOException,
                      java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Retrieves the data from next message that is ready to be delivered to the application.
 The bytes are returned as return value.
 The receive is a blocking function, waits until there are data to be received or the timeout expires.
 This function allows to specify a value for the timeout.
 Specifying a timeout of 0 implies that the default timeout should be used whereas a timeout
 of -1 implies wait indefinitely. The default timeout is -1.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD>a buffer containing the data read;
                  <code>NULL</code> if an error occurred.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sreceive(byte[], byte[], long)"><!-- --></A><H3>
sreceive</H3>
<PRE>
public int <B>sreceive</B>(byte[]&nbsp;buf1,
                    byte[]&nbsp;buf2,
                    long&nbsp;timeout)
             throws java.io.IOException,
                    java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.
 Not specifying a timeout or a timeout of 0 implies that the default timeout should be used
 whereas a timeout of -1 implies wait indefinitely.
 The data is scattered into the buffers that are passed into the method.
 Note: Any additional data in the packet that will not fit in the buffers is discarded.
 <p>
 E.g.: if the caller passes in two buffers, sreceive (pBufOne, pBufTwo, iTimeout),
 and the method returns 4000, the implication is that pBufOne.length bytes were read into pBufOne,
 pBufTwo.length bytes into pBufTwo. If pBufOne.length+pBufTwo.length&#60;4000 all the data are read,
 otherwise some data is lost.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf1</CODE> - first byte array where data is copied for delivery.<DD><CODE>buf2</CODE> - second byte array where additional data is copied for delivery.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD>returns the total number of bytes that were copied into all the buffers;
                  <code>-1</code> in case of the connection being closed;
                  <code>0</code> in case no data is available within the specified timeout.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sreceive(byte[], int, int, byte[], int, int, long)"><!-- --></A><H3>
sreceive</H3>
<PRE>
public int <B>sreceive</B>(byte[]&nbsp;buf1,
                    int&nbsp;offset1,
                    int&nbsp;length1,
                    byte[]&nbsp;buf2,
                    int&nbsp;offset2,
                    int&nbsp;length2,
                    long&nbsp;timeout)
             throws java.io.IOException,
                    java.lang.IllegalArgumentException,
                    java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.
 Not specifying a timeout or a timeout of 0 implies that the default timeout should be used
 whereas a timeout of -1 implies wait indefinitely.
 The data is scattered into the buffers that are passed into the method.
 The pointer to the buffer and the buffer size arguments must be passed in pairs.
 Note: Any additional data in the packet that will not fit in the buffers is discarded.
 <p>
 E.g.: if the caller passes in two buffers, sreceive (pBufOne, 0, 8, pBufTwo, 0, 1024, iTimeout),
 and the method returns 500, the implication is that 8 bytes were read into pBufOne and 492 bytes into
 pBufTwo.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf1</CODE> - first byte array where data is copied for delivery.<DD><CODE>offset1</CODE> - the point in the first buffer where we start to copy the data.<DD><CODE>length1</CODE> - the number of bytes that are copied into the first buffer.<DD><CODE>buf2</CODE> - second byte array where additional data is copied for delivery.<DD><CODE>offset2</CODE> - the point in the second buffer where we start to copy the data.<DD><CODE>length2</CODE> - the number of bytes that are copied into the second buffer.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD>returns the total number of bytes that were copied into all the buffers;
                  <code>-1</code> in case of the connection being closed;
                  <code>0</code> in case no data is available within the specified timeout.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters offset or length are illegal for buffer.</DL>
</DD>
</DL>
<HR>

<A NAME="sreceive(byte[], byte[], byte[], long)"><!-- --></A><H3>
sreceive</H3>
<PRE>
public int <B>sreceive</B>(byte[]&nbsp;buf1,
                    byte[]&nbsp;buf2,
                    byte[]&nbsp;buf3,
                    long&nbsp;timeout)
             throws java.io.IOException,
                    java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.
 Not specifying a timeout or a timeout of 0 implies that the default timeout should be used
 whereas a timeout of -1 implies wait indefinitely.
 The data is scattered into the buffers that are passed into the method.
 The pointer to the buffer and the buffer size arguments must be passed in pairs.
 Note: Any additional data in the packet that will not fit in the buffers is discarded.
 <p>
 E.g.: if the caller passes in three buffers, sreceive (pBufOne, pBufTwo, pBufThree, iTimeout),
 and the method returns 4000, the implication is that pBufOne.length bytes were read into pBufOne,
 pBufTwo.length bytes into pBufTwo, and the remaining pBufThree.length bytes into pBufThree.
 If pBufOne.length+pBufTwo.length+pBufThree.length&#60;4000 all the data are read, otherwise some data is lost.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf1</CODE> - first byte array where data is copied for delivery.<DD><CODE>buf2</CODE> - second byte array where additional data is copied for delivery.<DD><CODE>buf3</CODE> - third byte array where additional data is copied for delivery.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD>returns the total number of bytes that were copied into all the buffers;
                  <code>-1</code> in case of the connection being closed;
                  <code>0</code> in case no data is available within the specified timeout.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sreceive(byte[], int, int, byte[], int, int, byte[], int, int, long)"><!-- --></A><H3>
sreceive</H3>
<PRE>
public int <B>sreceive</B>(byte[]&nbsp;buf1,
                    int&nbsp;offset1,
                    int&nbsp;length1,
                    byte[]&nbsp;buf2,
                    int&nbsp;offset2,
                    int&nbsp;length2,
                    byte[]&nbsp;buf3,
                    int&nbsp;offset3,
                    int&nbsp;length3,
                    long&nbsp;timeout)
             throws java.io.IOException,
                    java.lang.IllegalArgumentException,
                    java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.
 Not specifying a timeout or a timeout of 0 implies that the default timeout should be used
 whereas a timeout of -1 implies wait indefinitely.
 The data is scattered into the buffers that are passed into the method.
 The pointer to the buffer and the buffer size arguments must be passed in pairs.
 Note: Any additional data in the packet that will not fit in the buffers is discarded.
 <p>
 E.g.: If the caller passes in three buffers, sreceive (pBufOne, 0, 8, pBufTwo, 0, 1024, pBufThree, 0, 4096, iTimeout),
 and the method returns 4000, the implication is that 8 bytes were read into pBufOne, 1024 bytes into pBufTwo,
 and the remaining 2968 bytes into pBufThree.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf1</CODE> - first byte array where data is copied for delivery.<DD><CODE>offset1</CODE> - the point in the first buffer where we start to copy the data.<DD><CODE>length1</CODE> - the number of bytes that are copied into the first buffer.<DD><CODE>buf2</CODE> - second byte array where additional data is copied for delivery.<DD><CODE>offset2</CODE> - the point in the second buffer where we start to copy the data.<DD><CODE>length2</CODE> - the number of bytes that are copied into the second buffer.<DD><CODE>buf3</CODE> - third byte array where additional data is copied for delivery.<DD><CODE>offset3</CODE> - the point in the third buffer where we start to copy the data.<DD><CODE>length3</CODE> - the number of bytes that are copied into the third buffer.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD>returns the total number of bytes that were copied into all the buffers;
                  <code>-1</code> in case of the connection being closed;
                  <code>0</code> in case no data is available within the specified timeout.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters offset or length are illegal for buffer.</DL>
</DD>
</DL>
<HR>

<A NAME="sreceive(byte[], byte[], byte[], byte[], long)"><!-- --></A><H3>
sreceive</H3>
<PRE>
public int <B>sreceive</B>(byte[]&nbsp;buf1,
                    byte[]&nbsp;buf2,
                    byte[]&nbsp;buf3,
                    byte[]&nbsp;buf4,
                    long&nbsp;timeout)
             throws java.io.IOException,
                    java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.
 Not specifying a timeout or a timeout of 0 implies that the default timeout should be used
 whereas a timeout of -1 implies wait indefinitely.
 The data is scattered into the buffers that are passed into the method.
 The pointer to the buffer and the buffer size arguments must be passed in pairs.
 Note: Any additional data in the packet that will not fit in the buffers is discarded.
 <p>
 E.g.: if the caller passes in four buffers, sreceive (pBufOne, pBufTwo, pBufThree, pBufFour, iTimeout),
 and the method returns 4000, the implication is that pBufOne.length bytes were read into pBufOne,
 pBufTwo.length bytes into pBufTwo, pBufThree.length bytes into pBufThree, and the remaining pBufFour.length
 bytes into pBufFour. If pBufOne.length+pBufTwo.length+pBufThree.length+pBufFour.length&#60;4000 all the
 data are read, otherwise some data is lost.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf1</CODE> - first byte array where data is copied for delivery.<DD><CODE>buf2</CODE> - second byte array where additional data is copied for delivery.<DD><CODE>buf3</CODE> - third byte array where additional data is copied for delivery.<DD><CODE>buf4</CODE> - fourth byte array where additional data is copied for delivery.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD>returns the total number of bytes that were copied into all the buffers;
                  <code>-1</code> in case of the connection being closed;
                  <code>0</code> in case no data is available within the specified timeout.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sreceive(byte[], int, int, byte[], int, int, byte[], int, int, byte[], int, int, long)"><!-- --></A><H3>
sreceive</H3>
<PRE>
public int <B>sreceive</B>(byte[]&nbsp;buf1,
                    int&nbsp;offset1,
                    int&nbsp;length1,
                    byte[]&nbsp;buf2,
                    int&nbsp;offset2,
                    int&nbsp;length2,
                    byte[]&nbsp;buf3,
                    int&nbsp;offset3,
                    int&nbsp;length3,
                    byte[]&nbsp;buf4,
                    int&nbsp;offset4,
                    int&nbsp;length4,
                    long&nbsp;timeout)
             throws java.io.IOException,
                    java.lang.IllegalArgumentException,
                    java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>Retrieves the data from the next message that is ready to be delivered to the application
 splitting the data in different buffers.
 Not specifying a timeout or a timeout of 0 implies that the default timeout should be used
 whereas a timeout of -1 implies wait indefinitely.
 The data is scattered into the buffers that are passed into the method.
 The pointer to the buffer and the buffer size arguments must be passed in pairs.
 Note: Any additional data in the packet that will not fit in the buffers is discarded.
 <p>
 E.g.: If the caller passes in four buffers, sreceive (pBufOne, 0, 8, pBufTwo, 0, 1024, pBufThree,
 0, 1024, pBufFour, 0 4096, iTimeout), and the method returns 4000, the implication is that 8 bytes
 were read into pBufOne, 1024 bytes into pBufTwo, 1024 bytes into pBufThree, and the remaining 1944
 bytes into pBufFour.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buf1</CODE> - first byte array where data is copied for delivery.<DD><CODE>offset1</CODE> - the point in the first buffer where we start to copy the data.<DD><CODE>length1</CODE> - the number of bytes that are copied into the first buffer.<DD><CODE>buf2</CODE> - second byte array where additional data is copied for delivery.<DD><CODE>offset2</CODE> - the point in the second buffer where we start to copy the data.<DD><CODE>length2</CODE> - the number of bytes that are copied into the second buffer.<DD><CODE>buf3</CODE> - third byte array where additional data is copied for delivery.<DD><CODE>offset3</CODE> - the point in the third buffer where we start to copy the data.<DD><CODE>length3</CODE> - the number of bytes that are copied into the third buffer.<DD><CODE>buf4</CODE> - fourth byte array where additional data is copied for delivery.<DD><CODE>offset4</CODE> - the point in the fourth buffer where we start to copy the data.<DD><CODE>length4</CODE> - the number of bytes that are copied into the fourth buffer.<DD><CODE>timeout</CODE> - milliseconds to wait for data.
<DT><B>Returns:</B><DD>returns the total number of bytes that were copied into all the buffers;
                  <code>-1</code> in case of the connection being closed;
                  <code>0</code> in case no data is available within the specified timeout.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters offset or length are illegal for buffer.</DL>
</DD>
</DL>
<HR>

<A NAME="replace(boolean, boolean, byte[], int, int, short, long, long)"><!-- --></A><H3>
replace</H3>
<PRE>
public int <B>replace</B>(boolean&nbsp;reliable,
                   boolean&nbsp;sequenced,
                   byte[]&nbsp;buffer,
                   int&nbsp;oldTag,
                   int&nbsp;newTag,
                   short&nbsp;priority,
                   long&nbsp;enqueueTimeout,
                   long&nbsp;retryTimeout)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>First cancels any previously enqueued messages that have been tagged with the specified <code>OldTag</code>
 value and then transmits the new message using the specified parameters. Note that there may be no old
 messages to cancel, in which case this call behaves just like a <code>send</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).<DD><CODE>buffer</CODE> - the buffer to be sent. The buffer is going to be sent entirely.<DD><CODE>oldTag</CODE> - tag of the messages to replace. Messages tagged with <code>oldTag</code> will be canceled.<DD><CODE>newTag</CODE> - tag of the new message to be enqueued. The value has to be >0.<DD><CODE>priority</CODE> - indicates the priority of the packet. The range of priority values is 0-255.<DD><CODE>enqueueTimeout</CODE> - indicates the length of time in milliseconds for which the method will wait if
                          there is no room in the outgoing buffer (a zero value indicates wait forever).<DD><CODE>retryTimeout</CODE> - indicates the length of time for which the transmitter will retransmit the packet
                          to ensure successful delivery (a zero value indicates retry with no time limit).
<DT><B>Returns:</B><DD><ul class="return">
                          <li><code>0</code> if ends with success;</li>
                          <li><code>-1</code> if an error occurred;</li>
                          <li><code>-2</code> if the <code>cancel</code> function ended with error;</li>
                          <li><code>-3</code> if the <code>send</code> function ended with error.</li>
                          </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="replace(boolean, boolean, byte[], int, int, int, int, short, long, long)"><!-- --></A><H3>
replace</H3>
<PRE>
public int <B>replace</B>(boolean&nbsp;reliable,
                   boolean&nbsp;sequenced,
                   byte[]&nbsp;buffer,
                   int&nbsp;offset,
                   int&nbsp;length,
                   int&nbsp;oldTag,
                   int&nbsp;newTag,
                   short&nbsp;priority,
                   long&nbsp;enqueueTimeout,
                   long&nbsp;retryTimeout)
            throws java.io.IOException,
                   java.lang.IllegalArgumentException,
                   java.lang.IndexOutOfBoundsException</PRE>
<DL>
<DD>First cancels any previously enqueued messages that have been tagged with the specified <code>OldTag</code>
 value and then transmits the new message using the specified parameters. Note that there may be no old
 messages to cancel, in which case this call behaves just like a <code>send</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).<DD><CODE>buffer</CODE> - the buffer to be sent.<DD><CODE>offset</CODE> - the position in the buffer we start to send from.
                          E.g. offset=10, we send buffer starting at the 10th byte in the array<DD><CODE>length</CODE> - the length for which we send.
                          E.g. length=50 we send 50 bytes of the buffer, starting at offset.
                          If offset=10, length=50 we send bytes from position 10 in the
                          buffer through position 60.<DD><CODE>oldTag</CODE> - tag of the messages to replace. Messages tagged with <code>oldTag</code> will be canceled.<DD><CODE>newTag</CODE> - tag of the new message to be enqueued. The value has to be >0.<DD><CODE>priority</CODE> - indicates the priority of the packet. The range of priority values is 0-255.<DD><CODE>enqueueTimeout</CODE> - indicates the length of time in milliseconds for which the method will wait if
                          there is no room in the outgoing buffer (a zero value indicates wait forever).<DD><CODE>retryTimeout</CODE> - indicates the length of time for which the transmitter will retransmit the packet
                          to ensure successful delivery (a zero value indicates retry with no time limit).
<DT><B>Returns:</B><DD><ul class="return">
                          <li><code>0</code> if ends with success;</li>
                          <li><code>-1</code> if an error occurred;</li>
                          <li><code>-2</code> if the <code>cancel</code> function ended with error;</li>
                          <li><code>-3</code> if the <code>send</code> function ended with error.</li>
                          </ul>
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE>
<DD><CODE>java.lang.IndexOutOfBoundsException</CODE> - if the parameters <code>offset</code> or 
                                              <code>length</code> are illegal for <code>buffer</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="cancel(boolean, boolean, int)"><!-- --></A><H3>
cancel</H3>
<PRE>
public int <B>cancel</B>(boolean&nbsp;reliable,
                  boolean&nbsp;sequenced,
                  int&nbsp;tagId)
           throws java.io.IOException,
                  java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Cancels (deletes) previously enqueued messages that have been tagged with the specified tag.
 Note that the messages may be pending transmission (which applies to all flows) or may have
 already been transmitted but not yet acknowledged (which only applies to reliable flows).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reliable</CODE> - select the type of flow: reliable (true) or unreliable (false).<DD><CODE>sequenced</CODE> - select the type of flow: sequenced (true) or unsequenced (false).<DD><CODE>tagId</CODE> - used to identify the packets to delete.
<DT><B>Returns:</B><DD>number of messages removed form the queues;
                      <code>-1</code> if an error occurred.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE><DT><B>See Also:</B><DD><A HREF="../../../us/ihmc/mockets/Mocket.Sender.html#cancel(int)"><CODE>to obtain the same result specifying less parameters.</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setConnectionLingerTime(long)"><!-- --></A><H3>
setConnectionLingerTime</H3>
<PRE>
public int <B>setConnectionLingerTime</B>(long&nbsp;lingerTime)
                            throws java.io.IOException,
                                   java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Sets the length of time (in milliseconds) for which a connection should linger before
 closing in case there is unsent data.
 A timeout value of 0 implies that the connection should wait indefinitely until all data has been sent.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lingerTime</CODE> - milliseconds for which the connection should linger.
<DT><B>Returns:</B><DD><code>0</code> if success.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getConnectionLingerTime()"><!-- --></A><H3>
getConnectionLingerTime</H3>
<PRE>
public long <B>getConnectionLingerTime</B>()
                             throws java.io.IOException,
                                    java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Returns the current setting for the connection linger time.
 The linger time represents the amount of time (in milliseconds) for which a connection
 should linger before closing in case there is unsent data.
 A value of zero means wait indefinitely.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>long representing the connection linger time in milliseconds.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE><DT><B>See Also:</B><DD><A HREF="../../../us/ihmc/mockets/Mocket.html#setConnectionLingerTime(long)"><CODE>setConnectionLingerTime(long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getStatistics()"><!-- --></A><H3>
getStatistics</H3>
<PRE>
public <A HREF="../../../us/ihmc/mockets/Mocket.Statistics.html" title="class in us.ihmc.mockets">Mocket.Statistics</A> <B>getStatistics</B>()
                                throws java.io.IOException,
                                       java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Returns a pointer to the Statistics class that maintains statistics about this mocket connection.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an object of class <code>Statistic</code>.
          <code>NULL</code> if the objects mocket or statistic are not initialized, mocket or statistic is null.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumMTU()"><!-- --></A><H3>
getMaximumMTU</H3>
<PRE>
public static int <B>getMaximumMTU</B>()
                         throws java.io.IOException,
                                java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Returns the maximum MTU that may be used.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>integer representing the maximum MTU that may be used.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getPeerName()"><!-- --></A><H3>
getPeerName</H3>
<PRE>
public java.net.SocketAddress <B>getPeerName</B>()
                                   throws java.io.IOException,
                                          java.lang.IllegalArgumentException</PRE>
<DL>
<DD>Extract the address of the peer in the form Socket Address.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the address, in the form Socket Address, of the peer;
          <code>NULL</code> if an error occurred.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE>
<DD><CODE>java.lang.IllegalArgumentException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A><H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL>
<DD>Native method that removes <code>mocket</code> object.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>finalize</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setIdentifier(java.lang.String)"><!-- --></A><H3>
setIdentifier</H3>
<PRE>
public void <B>setIdentifier</B>(java.lang.String&nbsp;identifier)</PRE>
<DL>
<DD>Sets a string to use as the application or user friendly identifier for this mocket instance.
 The identifier is used when sending out statistics and when logging information.
 Some suggestions include the name of the application, the purpose for this mocket, etc.
 May be set to NULL to clear a previously set identifier.
 NOTE: The string is copied internally, so the caller does not need to preserve the string
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>identifier</CODE> - string to be used to identify this mocket instance.</DL>
</DD>
</DL>
<HR>

<A NAME="getIdentifier()"><!-- --></A><H3>
getIdentifier</H3>
<PRE>
public java.lang.String <B>getIdentifier</B>()</PRE>
<DL>
<DD>Returns the identifier for this mocket instance.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>identifier of this mocket instance;
          <code>NULL</code> if no identifier is set.<DT><B>See Also:</B><DD><A HREF="../../../us/ihmc/mockets/Mocket.html#setIdentifier(java.lang.String)"><CODE>setIdentifier(java.lang.String)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../us/ihmc/mockets/package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../us/ihmc/mockets/Mocket.Sender.html" title="class in us.ihmc.mockets"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?us/ihmc/mockets/Mocket.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Mocket.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
